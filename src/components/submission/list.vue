<!--
Copyright 2017 ODK Central Developers
See the NOTICE file at the top-level directory of this distribution and at
https://github.com/getodk/central-frontend/blob/master/NOTICE.

This file is part of ODK Central. It is subject to the license terms in
the LICENSE file found in the top-level directory of this distribution and at
https://www.apache.org/licenses/LICENSE-2.0. No part of ODK Central,
including this file, may be copied, modified, propagated, or distributed
except according to the terms contained in the LICENSE file.
-->
<template>
  <div>
    <loading :state="$store.getters.initiallyLoading(['keys'])"/>
    <template v-if="formVersion != null && keys != null">
      <float-row class="table-actions">
        <template #left>
          <form class="form-inline">
            <div class="form-group">
              <refresh-button :configs="configsForRefresh"/>
            </div>
            <div class="form-group" style="margin-left: 10px;">
              <span class="icon-filter" style="color: #999; margin-right: 6px;"></span>
              <span>Filter by</span>
            </div>
            <div class="form-group" style="margin-left: 5px; margin-right: 5px;">
              <select class="form-control">
                <option value="">Alice Allison</option>
              </select>
            </div>
            <date-range-picker v-model="dateRange"
              :placeholder="$t('field.dateRange')"/>
            <div class="form-group" style="margin-left: 10px;">
              <select class="form-control">
                <option value="">4 of 20 columns shown</option>
              </select>
            </div>
          </form>
        </template>
        <template #right>
          <a v-if="managedKey == null" id="submission-list-download-button"
            :href="downloadPath" class="btn btn-primary" target="_blank">
            <span class="icon-arrow-circle-down"></span>{{ downloadButtonText }}
          </a>
          <button v-else id="submission-list-download-button" type="button"
            class="btn btn-primary" @click="showModal('decrypt')">
            <span class="icon-arrow-circle-down"></span>{{ downloadButtonText }}&hellip;
          </button>

          <button id="submission-list-analyze-button" type="button"
            class="btn btn-primary" :disabled="analyzeDisabled"
            :title="analyzeDisabled ? $t('analyzeDisabled') : null"
            @click="showModal('analyze')">
            <span class="icon-plug"></span>{{ $t('action.analyze') }}&hellip;
          </button>
        </template>
      </float-row>
      <template v-if="submissions != null">
        <p v-if="submissions.length === 0" class="empty-table-message">
          {{ $t('emptyTable') }}
        </p>
        <submission-table v-else-if="fields != null" :base-url="baseUrl"
          :submissions="submissions" :fields="fields"
          :original-count="originalCount" :shows-submitter="showsSubmitter"/>
      </template>
      <div v-if="message != null" id="submission-list-message">
        <div id="submission-list-spinner-container">
          <spinner :state="message.spinner"/>
        </div>
        <div id="submission-list-message-text">{{ message.text }}</div>
      </div>
    </template>

    <submission-decrypt :state="decrypt.state" :managed-key="managedKey"
      :form-action="downloadPath" @hide="hideModal('decrypt')"/>
    <submission-analyze :state="analyze.state" :base-url="baseUrl"
      @hide="hideModal('analyze')"/>
  </div>
</template>

<script>
import { DateTime } from 'luxon';

import DateRangePicker from '../date-range-picker.vue';
import FloatRow from '../float-row.vue';
import Form from '../../presenters/form';
import Loading from '../loading.vue';
import RefreshButton from '../refresh-button.vue';
import Spinner from '../spinner.vue';
import SubmissionAnalyze from './analyze.vue';
import SubmissionDecrypt from './decrypt.vue';
import SubmissionTable from './table.vue';
import modal from '../../mixins/modal';
import { requestData } from '../../store/modules/request';

const REQUEST_KEYS = ['keys', 'fields', 'submissionsChunk'];
const MAX_SMALL_CHUNKS = 4;

export default {
  name: 'SubmissionList',
  components: {
    DateRangePicker,
    FloatRow,
    Loading,
    RefreshButton,
    Spinner,
    SubmissionAnalyze,
    SubmissionDecrypt,
    SubmissionTable
  },
  mixins: [modal()],
  props: {
    baseUrl: {
      type: String,
      required: true
    },
    formVersion: Form, // eslint-disable-line vue/require-default-prop
    showsSubmitter: {
      type: Boolean,
      default: false
    },
    chunkSizes: {
      type: Object,
      default: () => ({ small: 250, large: 1000 })
    },
    // Function that returns true if the user has scrolled to the bottom of the
    // page (or close to it) and false if not. Implementing this as a prop in
    // order to facilitate testing.
    scrolledToBottom: {
      type: Function,
      default: () =>
        // Using pageYOffset rather than scrollY in order to support IE.
        window.pageYOffset + window.innerHeight >= document.body.offsetHeight - 5
    }
  },
  data() {
    return {
      submissions: null,
      instanceIds: new Set(),
      // The count of submissions at the time of the initial fetch or last
      // refresh
      originalCount: null,
      // The number of chunks that have been fetched since the initial fetch or
      // last refresh
      chunkCount: 0,
      dateRange: [
        DateTime.local().startOf('day').minus({ days: 6 }),
        DateTime.local().startOf('day')
      ],
      message: null,
      // Modals
      decrypt: {
        state: false
      },
      analyze: {
        state: false
      }
    };
  },
  computed: {
    ...requestData(REQUEST_KEYS),
    dataExists() {
      return this.$store.getters.dataExists(REQUEST_KEYS);
    },
    configsForRefresh() {
      return [{
        key: 'submissionsChunk',
        url: this.oDataUrl(this.chunkSizes.small),
        success: () => {
          this.processChunk();
        }
      }];
    },
    // Returns a managed key if there is one among this.keys. Returns null if
    // there is no managed key or if this.keys is null (because this.keys is
    // still loading, for example).
    managedKey() {
      return this.keys != null ? this.keys.find(key => key.managed) : null;
    },
    downloadPath() {
      return `${this.baseUrl}/submissions.csv.zip`;
    },
    downloadButtonText() {
      return this.$tcn('action.download.withCount', 10000);
    },
    analyzeDisabled() {
      // If an encrypted form has no submissions, then there will never be
      // decrypted submissions available to OData (as long as the form remains
      // encrypted).
      return (this.formVersion.keyId != null && this.formVersion.submissions === 0) ||
        this.keys.length !== 0;
    }
  },
  created() {
    this.fetchInitialData();
  },
  mounted() {
    $(window).on('scroll.submission-list', this.onScroll);
  },
  beforeDestroy() {
    $(window).off('.submission-list');
  },
  methods: {
    loadingMessageText({ top, skip = 0 }) {
      if (skip === 0) {
        if (this.formVersion == null || this.formVersion.submissions === 0)
          return this.$t('loading.withoutCount');
        if (this.formVersion.submissions <= top)
          return this.$tcn('loading.all', this.formVersion.submissions);
        return this.$t('loading.first', { top, count: this.formVersion.submissions });
      }
      const remaining = this.originalCount - this.submissions.length;
      // This case should be rare or impossible.
      if (remaining <= 0) return this.$t('loading.withoutCount');
      if (remaining > top)
        return this.$t('loading.middle', { top, count: remaining });
      return remaining > 1
        ? this.$tcn('loading.last.multiple', remaining)
        : this.$t('loading.last.one');
    },
    oDataUrl(top, skip = 0) {
      return `${this.baseUrl}.svc/Submissions?%24top=${top}&%24skip=${skip}&%24count=true`;
    },
    processChunk(replace = true) {
      if (replace) {
        this.submissions = this.submissionsChunk.value;
        this.instanceIds.clear();
        for (const submission of this.submissions)
          this.instanceIds.add(submission.__id);
        this.originalCount = this.submissionsChunk['@odata.count'];
        this.chunkCount = 1;
      } else {
        const lastSubmission = this.submissions[this.submissions.length - 1];
        const lastSubmissionDate = lastSubmission.__system.submissionDate;
        for (const submission of this.submissionsChunk.value) {
          // If one or more submissions have been created since the initial
          // fetch or last refresh, then the latest chunk of submissions may
          // include a newly created submission or a submission that is already
          // shown in the table.
          if (submission.__system.submissionDate <= lastSubmissionDate &&
            !this.instanceIds.has(submission.__id)) {
            this.submissions.push(submission);
            this.instanceIds.add(submission.__id);
          }
        }
        this.chunkCount += 1;
      }

      const remaining = this.originalCount - this.submissions.length;
      this.message = remaining > 0
        ? { text: this.$tcn('remaining', remaining), spinner: false }
        : null;
    },
    fetchInitialData() {
      this.message = {
        text: this.loadingMessageText({ top: this.chunkSizes.small }),
        spinner: true
      };
      this.$store.dispatch('get', [
        {
          // We do not reconcile `keys` and formDraft.keyId.
          key: 'keys',
          url: `${this.baseUrl}/submissions/keys`
        },
        {
          key: 'fields',
          url: `${this.baseUrl}/fields?odata=true`
        },
        {
          key: 'submissionsChunk',
          url: this.oDataUrl(this.chunkSizes.small),
          success: () => {
            this.processChunk();
          }
        }
      ])
        .catch(() => {
          this.message = null;
        });
    },
    // Returns the value of the $skip query parameter for skipping the specified
    // number of chunks.
    skip(chunkCount) {
      if (chunkCount <= MAX_SMALL_CHUNKS)
        return chunkCount * this.chunkSizes.small;
      return (MAX_SMALL_CHUNKS * this.chunkSizes.small) +
        ((chunkCount - MAX_SMALL_CHUNKS) * this.chunkSizes.large);
    },
    // This method may need to change once we support submission deletion.
    onScroll() {
      if (this.formVersion == null || !this.dataExists) return;
      // Return if the next chunk of submissions is already loading.
      if (this.$store.getters.loading('submissionsChunk')) return;
      const skip = this.skip(this.chunkCount);
      if (skip >= this.formVersion.submissions || !this.scrolledToBottom())
        return;
      const top = this.chunkCount < MAX_SMALL_CHUNKS
        ? this.chunkSizes.small
        : this.chunkSizes.large;
      this.message = {
        text: this.loadingMessageText({ top, skip }),
        spinner: true
      };
      this.$store.dispatch('get', [{
        key: 'submissionsChunk',
        url: this.oDataUrl(top, skip),
        success: () => {
          this.processChunk(false);
        }
      }])
        .catch(() => {
          this.message = null;
        });
    }
  }
};
</script>

<style lang="scss">
@import '../../assets/scss/variables';

#submission-list-download-button {
  margin-right: 5px;
}

#submission-list-message {
  margin-left: 28px;
  padding-bottom: 38px;
  position: relative;

  #submission-list-spinner-container {
    float: left;
    margin-right: 8px;
    position: absolute;
    top: 8px;
    width: 16px; // TODO: eventually probably better not to default spinner to center.
  }

  #submission-list-message-text {
    color: #555;
    font-size: 12px;
    padding-left: 24px;
  }
}
</style>

<i18n lang="json5">
{
  "en": {
    "action": {
      "download": {
        "withCount": "Download all {count} record | Download all {count} records",
        "withoutCount": "Download all records"
      },
      "analyze": "Analyze via OData"
    },
    "analyzeDisabled": "OData access is unavailable due to Form encryption",
    "loading": {
      // This text is shown when the number of Submissions loading is unknown.
      "withoutCount": "Loading Submissions…",
      "all": "Loading {count} Submission… | Loading {count} Submissions…",
      // {top} and {count} are both numbers that are at least 250.
      "first": "Loading the first {top} of {count} Submissions…",
      // {top} and {count} are both numbers that are at least 250.
      "middle": "Loading {top} more of {count} remaining Submissions…",
      "last": {
        "multiple": "Loading the last {count} Submission… | Loading the last {count} Submissions…",
        "one": "Loading the last Submission…"
      }
    },
    "emptyTable": "There are no Submissions yet.",
    "remaining": "{count} row remains. | {count} rows remain."
  }
}
</i18n>

<!-- Autogenerated by destructure.js -->
<i18n>
{
  "cs": {
    "action": {
      "download": {
        "withCount": "Stáhnout {count} záznam | Stáhnout tyto {count} záznamy | Stáhnout všech {count} záznamů | Stáhnout všech {count} záznamů",
        "withoutCount": "Stáhnout všechny záznamy"
      },
      "analyze": "Analyzovat přes OData"
    },
    "analyzeDisabled": "Přístup k datům OData není k dispozici kvůli šifrování formulářů",
    "loading": {
      "withoutCount": "Načítání příspěvků…",
      "all": "Načítání {count} příspěvku ... | Načítání {count} příspěvků ... | Načítání {count} příspěvků ... | Načítání {count} příspěvků ...",
      "first": "Načítání prvních {top} ze {count} příspěvků…",
      "middle": "Načítání {top} dalších ze {count} zbývajících příspěvků…",
      "last": {
        "multiple": "Načítání posledního {count} příspěvku… | Načítání posledních {count} příspěvků… | Načítání posledních {count} příspěvků… | Načítání posledních {count} příspěvků…",
        "one": "Načítání posledního příspěvku…"
      }
    },
    "emptyTable": "Zatím neexistují žádné příspěvky.",
    "remaining": "{count} řádka zbývá | {count} řádky zbývají. | {count} řádek zbývá. | {count} řádek zbývá."
  },
  "de": {
    "action": {
      "download": {
        "withCount": "{count} Datensatz herunterladen | Alle {count} Datensätze herunterladen",
        "withoutCount": "Alle Datensätze herunterladen"
      },
      "analyze": "Mittels OData analysieren"
    },
    "analyzeDisabled": "OData-Zugriff ist wegen Formularverschlüsselung nicht verfügbar.",
    "loading": {
      "withoutCount": "Übermittlungen laden...",
      "all": "{count} Übermittlung laden... | {count} Übermittlungen laden...",
      "first": "Die ersten {top} von {count} Übermittlungen laden...",
      "middle": "{top} weitere von {count} verbliebenen Übermittlungen laden...",
      "last": {
        "multiple": "Die letzte {count} Übermittlung laden... | Die letzten {count} Übermittlungen laden...",
        "one": "Letzte Übermittlung laden..."
      }
    },
    "emptyTable": "Es gibt noch keine Übermittlungen.",
    "remaining": "{count} Zeile verbleibend. | {count} Zeilen verbleibend."
  },
  "es": {
    "action": {
      "download": {
        "withCount": "Descargar {count} registro | Descargar todos los {count} registros",
        "withoutCount": "Descargar todos los registros"
      },
      "analyze": "Analizar vía OData"
    },
    "analyzeDisabled": "El acceso a OData no está disponible debido al cifrado del formulario",
    "loading": {
      "withoutCount": "Cargando los envíos...",
      "all": "Cargando {count} envío... | Cargando {count} envíos...",
      "first": "Cargando los primeros {top} de {count} envíos...",
      "middle": "Cargando {top} más de {count} envíos restantes...",
      "last": {
        "multiple": "Cargando el último {count} envío... | Cargando los últimos {count} envíos...",
        "one": "Cargando el último envío..."
      }
    },
    "emptyTable": "No hay envíos todavía.",
    "remaining": "{count} archivo permanece. | {count} archivos permanecen."
  },
  "fr": {
    "action": {
      "download": {
        "withCount": "Télécharger le {count} enregistrement | Télécharger tous les {count} enregistrements",
        "withoutCount": "Télécharger tous les enregistrements"
      },
      "analyze": "Analyser via OData"
    },
    "analyzeDisabled": "L'accès à OData n'est pas disponible en raison du chiffrement du formulaire",
    "loading": {
      "withoutCount": "Chargement des soumissions...",
      "all": "Chargement de {count} soumission... | Chargement de {count} soumissions...",
      "first": "Chargement des premières {top} sur {count} soumissions...",
      "middle": "Chargement de {top} autres des {count} soumissions restantes...",
      "last": {
        "multiple": "Chargement de la {count} dernière soumissions... | Chargement des {count} dernières soumissions...",
        "one": "Chargement la dernière soumission..."
      }
    },
    "emptyTable": "Il n'y a pas encore de soumissions.",
    "remaining": "{count} ligne restante. | {count} lignes restantes."
  },
  "id": {
    "action": {
      "download": {
        "withCount": "Unduh semua {count} catatan.",
        "withoutCount": "Unduh semua catatan"
      },
      "analyze": "Analisis lewat OData"
    },
    "analyzeDisabled": "Akses OData tidak tersedia karena enkripsi formulir",
    "loading": {
      "withoutCount": "Memuat kiriman data...",
      "all": "Memuat {count} kiriman data...",
      "first": "Memuat {top} pertama dari {count} kiriman data...",
      "middle": "Memuat {top} lebih dari {count} sisa kiriman data...",
      "last": {
        "multiple": "Memuat {count} kiriman data terakhir...",
        "one": "Memuat kiriman data terakhir..."
      }
    },
    "emptyTable": "Belum ada kiriman data.",
    "remaining": "{count} baris tersisa."
  }
}
</i18n>
